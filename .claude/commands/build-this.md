---
description: Build applications from natural language using Intelligence System patterns
globs:
alwaysApply: false
version: 3.0
encoding: UTF-8
---

# Build This - Natural Language Application Builder

<ai_meta>
  <parsing_rules>
    - Process XML blocks first for structured development
    - Execute building process in sequential steps
    - Use transparent communication throughout
    - Apply pattern-based development approaches
  </parsing_rules>
  <communication_style>
    - Explain technical decisions in accessible language
    - Show progress and celebrate milestones
    - Provide transparent status updates
    - Adapt explanations to user skill level
  </communication_style>
</ai_meta>

## Overview

<purpose>
  - Build complete applications from natural language descriptions
  - Use proven patterns and best practices automatically
  - Provide transparent development process with progress tracking
  - Create production-ready code with proper architecture
</purpose>

<context>
  - Part of Claude Intelligence System enhanced workflows
  - Uses pattern-based development for efficiency and quality
  - Focuses on natural language accessibility for all skill levels
  - Integrates with Agent-OS planning and Codebase-OS quality processes
</context>

<prerequisites>
  - Clear description of what to build
  - Development environment available
  - Access to necessary tools and frameworks
</prerequisites>

## Your Request
Build: $ARGUMENTS

<process_flow>

<step number="1" name="requirement_analysis">

### Step 1: Analyze and Understand Requirements

<step_metadata>
  <action>natural language analysis</action>
  <purpose>translate user intent into technical requirements</purpose>
</step_metadata>

<analysis_framework>
  <application_type>
    - E-commerce, SaaS, Internal Tool, Mobile Backend, etc.
    - Complexity level and target users
    - Key functionality and features needed
  </application_type>
  <technical_requirements>
    - Frontend needs (web, mobile, desktop)
    - Backend requirements (API, database, authentication)
    - Integration needs (payments, third-party services)
    - Deployment and hosting considerations
  </technical_requirements>
  <user_experience>
    - Target user personas and skill levels
    - Key user journeys and workflows
    - Design and accessibility requirements
  </user_experience>
</analysis_framework>

<instructions>
  ACTION: Analyze the natural language request thoroughly
  IDENTIFY: Core application type and requirements
  TRANSLATE: User intent into technical specifications
  COMMUNICATE: Understanding back to user for confirmation
</instructions>

</step>

<step number="2" name="pattern_matching">

### Step 2: Apply Intelligent Pattern Selection

<step_metadata>
  <action>pattern-based architecture selection</action>
  <purpose>choose optimal technology stack and approach</purpose>
</step_metadata>

<pattern_library>
  <ecommerce_patterns>
    - React + Node.js + PostgreSQL + Stripe
    - Product catalog, cart, checkout, user accounts
    - Payment processing and order management
  </ecommerce_patterns>
  <saas_patterns>
    - Next.js + PostgreSQL + Auth0 + Stripe
    - Multi-tenant architecture with subscription billing
    - User management and organizational features
  </saas_patterns>
  <internal_tools>
    - React + Express + PostgreSQL + JWT
    - Admin dashboards with role-based access
    - Data visualization and reporting
  </internal_tools>
  <mobile_backend>
    - Node.js + MongoDB + JWT + AWS S3
    - RESTful APIs with file storage
    - Push notifications and real-time features
  </mobile_backend>
</pattern_library>

<selection_criteria>
  - Match application type to proven patterns
  - Consider scale and performance requirements
  - Apply security best practices automatically
  - Choose technologies for maintainability
</selection_criteria>

<instructions>
  ACTION: Select optimal pattern based on requirements analysis
  EXPLAIN: Why specific technologies and approaches were chosen
  HIGHLIGHT: Benefits and trade-offs of selected architecture
  PREPARE: For efficient implementation using proven templates
</instructions>

</step>

<step number="3" name="project_setup">

### Step 3: Create Project Structure and Foundation

<step_metadata>
  <action>scaffold project architecture</action>
  <purpose>establish solid foundation for development</purpose>
</step_metadata>

<project_structure>
  <frontend_setup>
    - Initialize framework (React, Next.js, etc.)
    - Configure build tools and development environment
    - Set up routing and basic component structure
    - Implement styling framework and theme
  </frontend_setup>
  <backend_setup>
    - Initialize server framework (Express, FastAPI, etc.)
    - Configure database connection and models
    - Set up authentication and middleware
    - Create API structure and error handling
  </backend_setup>
  <development_tools>
    - Configure linting and code formatting
    - Set up testing framework and initial tests
    - Configure environment variables and secrets
    - Initialize version control and documentation
  </development_tools>
</project_structure>

<instructions>
  ACTION: Create comprehensive project foundation
  IMPLEMENT: Best practices for project organization
  CONFIGURE: Development tools and quality measures
  COMMUNICATE: Progress and next steps clearly
</instructions>

</step>

<step number="4" name="core_features">

### Step 4: Implement Core Functionality

<step_metadata>
  <action>build primary application features</action>
  <purpose>create working application with key capabilities</purpose>
</step_metadata>

<feature_implementation>
  <user_interface>
    - Create responsive, accessible UI components
    - Implement user flows and navigation
    - Add proper error handling and loading states
    - Apply consistent styling and branding
  </user_interface>
  <business_logic>
    - Implement core application functionality
    - Add data validation and processing
    - Create proper state management
    - Handle edge cases and error scenarios
  </business_logic>
  <data_layer>
    - Design and implement database schema
    - Create API endpoints with proper validation
    - Implement authentication and authorization
    - Add data persistence and retrieval
  </data_layer>
</feature_implementation>

<quality_measures>
  - Write tests for critical functionality
  - Implement proper error handling throughout
  - Add security measures and input validation
  - Optimize for performance and user experience
</quality_measures>

<instructions>
  ACTION: Build all core features systematically
  PRIORITIZE: Most important functionality first
  ENSURE: Quality and security throughout implementation
  UPDATE: User on progress with specific milestones
</instructions>

</step>

<step number="5" name="enhancement_and_polish">

### Step 5: Add Enhancements and Polish

<step_metadata>
  <action>improve user experience and add value</action>
  <purpose>create professional, production-ready application</purpose>
</step_metadata>

<enhancement_areas>
  <user_experience>
    - Add smooth animations and transitions
    - Implement proper loading and success states
    - Create helpful error messages and guidance
    - Optimize for mobile and accessibility
  </user_experience>
  <functionality_expansion>
    - Add suggested features based on app type
    - Implement search and filtering capabilities
    - Create admin/management interfaces
    - Add analytics and monitoring hooks
  </functionality_expansion>
  <production_readiness>
    - Implement proper logging and monitoring
    - Add performance optimizations
    - Configure security headers and measures
    - Create deployment configuration
  </production_readiness>
</enhancement_areas>

<instructions>
  ACTION: Enhance application with valuable features
  FOCUS: User experience and production readiness
  SUGGEST: Additional features based on application type
  PREPARE: Application for deployment and use
</instructions>

</step>

<step number="6" name="testing_and_validation">

### Step 6: Comprehensive Testing and Validation

<step_metadata>
  <action>validate application functionality and quality</action>
  <purpose>ensure reliable, bug-free operation</purpose>
</step_metadata>

<testing_strategy>
  <functionality_testing>
    - Test all user flows and core features
    - Validate API endpoints and data handling
    - Test authentication and authorization
    - Verify error handling and edge cases
  </functionality_testing>
  <performance_testing>
    - Check page load times and responsiveness
    - Test database query performance
    - Validate mobile experience
    - Monitor memory usage and optimization opportunities
  </performance_testing>
  <security_validation>
    - Test authentication and session handling
    - Validate input sanitization and SQL injection prevention
    - Check for XSS vulnerabilities
    - Verify proper access controls
  </security_validation>
</testing_strategy>

<instructions>
  ACTION: Run comprehensive testing on all functionality
  IDENTIFY: Any issues or improvement opportunities
  FIX: Problems immediately and thoroughly
  CONFIRM: Application is ready for deployment
</instructions>

</step>

<step number="7" name="deployment_preparation">

### Step 7: Prepare for Deployment

<step_metadata>
  <action>configure deployment and provide guidance</action>
  <purpose>enable easy deployment and ongoing maintenance</purpose>
</step_metadata>

<deployment_options>
  <frontend_deployment>
    - Vercel (recommended for React/Next.js)
    - Netlify (great for static sites)
    - AWS S3 + CloudFront (scalable option)
  </frontend_deployment>
  <backend_deployment>
    - Railway (easy Node.js deployment)
    - Heroku (simple with database add-ons)
    - AWS/DigitalOcean (more control and scaling)
  </backend_deployment>
  <database_hosting>
    - PostgreSQL on Railway/Heroku
    - AWS RDS for production scale
    - MongoDB Atlas for document-based apps
  </database_hosting>
</deployment_options>

<deployment_guide>
  - Environment variable configuration
  - Database migration and seeding instructions
  - Domain setup and SSL configuration
  - Monitoring and backup recommendations
</deployment_guide>

<instructions>
  ACTION: Prepare application for deployment
  PROVIDE: Clear deployment instructions and options
  CONFIGURE: Environment variables and settings
  GUIDE: User through deployment process
</instructions>

</step>

</process_flow>

## Success Confirmation

<completion_message>
```
✅ APPLICATION BUILD COMPLETE!

🎉 Your application has been successfully built with:
   ├── 🏗️  Solid architecture using proven patterns
   ├── 🎨 Professional UI with responsive design
   ├── 🔧 Core functionality fully implemented
   ├── 🛡️  Security best practices applied
   ├── 🧪 Comprehensive testing completed
   └── 🚀 Ready for deployment

📊 What was built:
   ├── Frontend: [Technology used]
   ├── Backend: [API and database setup]  
   ├── Features: [List of implemented features]
   ├── Testing: [Test coverage and validation]
   └── Documentation: [Usage and deployment guides]

🚀 Next steps:
   1. Review the implementation and test functionality
   2. Deploy using provided deployment guide
   3. Customize styling and branding as needed
   4. Add any additional features you thought of

Your application is production-ready! 🌟
```
</completion_message>

## Operational Guidelines

Throughout the building process:
- Maintain transparent communication about progress and decisions
- Use proven patterns and best practices automatically
- Adapt explanations to user's technical skill level
- Provide specific, actionable next steps
- Celebrate milestones and achievements
- Focus on creating genuinely useful, production-ready applications